{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useState, useEffect, useReducer, useLayoutEffect, useContext, useRef, memo, useMemo, useCallback } from \"react\";\nimport MyContext from \"../../lib/my-context\";\n\nfunction countReducer(state, action) {\n  switch (action.type) {\n    case \"add\":\n      return state + 1;\n\n    case \"minus\":\n      return state - 1;\n\n    default:\n      return state;\n  }\n}\n\nfunction MyCountFunc() {\n  var _useReducer = useReducer(countReducer, 0),\n      count = _useReducer[0],\n      dispatchCount = _useReducer[1];\n\n  var _useState = useState(\"lyn\"),\n      name = _useState[0],\n      setName = _useState[1];\n\n  var countRef = useRef();\n  countRef.current = count; // 不加useMemo时候config每次都会重新渲染，都不一样，所以要缓存一下\n\n  var config = useMemo(function () {\n    return {\n      text: \"count is \".concat(count),\n      color: count > 3 ? \"red\" : \"blue\"\n    };\n  }, [count]); // 如果放在onClick中，每次声明都是声明新的，还是每次都渲染，，方法提出来，然后用useCallback包裹住匿名函数，\n\n  var handleButtonClick = useCallback(function () {\n    return dispatchCount({\n      type: \"add\"\n    });\n  }, []);\n\n  var handleAlertButtonClick = function handleAlertButtonClick() {\n    setTimeout(function () {\n      // alert(count)\n      alert(countRef.current);\n    }, 2000);\n  };\n\n  return __jsx(\"div\", null, __jsx(\"input\", {\n    value: name,\n    onChange: function onChange(e) {\n      return setName(e.target.value);\n    }\n  }), __jsx(Child, {\n    config: config,\n    onButtonClick: handleButtonClick\n  }), __jsx(\"button\", {\n    onClick: handleAlertButtonClick\n  }, \"alert count\"));\n}\n\nvar Child = memo(function Child(_ref) {\n  var onButtonClick = _ref.onButtonClick,\n      config = _ref.config;\n  console.log(\"child render\");\n  return __jsx(\"button\", {\n    onClick: onButtonClick,\n    style: {\n      color: config.color\n    }\n  }, config.text);\n});\nexport default MyCountFunc;","map":{"version":3,"sources":["D:/GitHub/nextjs-project/pages/test/b.js"],"names":["React","useState","useEffect","useReducer","useLayoutEffect","useContext","useRef","memo","useMemo","useCallback","MyContext","countReducer","state","action","type","MyCountFunc","count","dispatchCount","name","setName","countRef","current","config","text","color","handleButtonClick","handleAlertButtonClick","setTimeout","alert","e","target","value","Child","onButtonClick","console","log"],"mappings":";AAAA,OAAOA,KAAP,IACEC,QADF,EAEEC,SAFF,EAGEC,UAHF,EAIEC,eAJF,EAKEC,UALF,EAMEC,MANF,EAOEC,IAPF,EAQEC,OARF,EASEC,WATF,QAUO,OAVP;AAYA,OAAOC,SAAP,MAAsB,sBAAtB;;AAEA,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,MAA7B,EAAqC;AACnC,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,KAAL;AACE,aAAOF,KAAK,GAAG,CAAf;;AACF,SAAK,OAAL;AACE,aAAOA,KAAK,GAAG,CAAf;;AACF;AACE,aAAOA,KAAP;AANJ;AAQD;;AAED,SAASG,WAAT,GAAuB;AAAA,oBACUZ,UAAU,CAACQ,YAAD,EAAe,CAAf,CADpB;AAAA,MACdK,KADc;AAAA,MACPC,aADO;;AAAA,kBAEGhB,QAAQ,CAAC,KAAD,CAFX;AAAA,MAEdiB,IAFc;AAAA,MAERC,OAFQ;;AAIrB,MAAMC,QAAQ,GAAGd,MAAM,EAAvB;AACAc,EAAAA,QAAQ,CAACC,OAAT,GAAmBL,KAAnB,CALqB,CAMrB;;AACA,MAAMM,MAAM,GAAGd,OAAO,CACpB;AAAA,WAAO;AACLe,MAAAA,IAAI,qBAAcP,KAAd,CADC;AAELQ,MAAAA,KAAK,EAAER,KAAK,GAAG,CAAR,GAAY,KAAZ,GAAoB;AAFtB,KAAP;AAAA,GADoB,EAKpB,CAACA,KAAD,CALoB,CAAtB,CAPqB,CAcrB;;AACA,MAAMS,iBAAiB,GAAGhB,WAAW,CACnC;AAAA,WAAMQ,aAAa,CAAC;AAAEH,MAAAA,IAAI,EAAE;AAAR,KAAD,CAAnB;AAAA,GADmC,EAEnC,EAFmC,CAArC;;AAKA,MAAMY,sBAAsB,GAAG,SAAzBA,sBAAyB,GAAM;AACnCC,IAAAA,UAAU,CAAC,YAAM;AACf;AACAC,MAAAA,KAAK,CAACR,QAAQ,CAACC,OAAV,CAAL;AACD,KAHS,EAGP,IAHO,CAAV;AAID,GALD;;AAOA,SACE,mBACE;AAAO,IAAA,KAAK,EAAEH,IAAd;AAAoB,IAAA,QAAQ,EAAE,kBAAAW,CAAC;AAAA,aAAIV,OAAO,CAACU,CAAC,CAACC,MAAF,CAASC,KAAV,CAAX;AAAA;AAA/B,IADF,EAEE,MAAC,KAAD;AAAO,IAAA,MAAM,EAAET,MAAf;AAAuB,IAAA,aAAa,EAAEG;AAAtC,IAFF,EAGE;AAAQ,IAAA,OAAO,EAAEC;AAAjB,mBAHF,CADF;AAOD;;AAED,IAAMM,KAAK,GAAGzB,IAAI,CAAC,SAASyB,KAAT,OAA0C;AAAA,MAAzBC,aAAyB,QAAzBA,aAAyB;AAAA,MAAVX,MAAU,QAAVA,MAAU;AAC3DY,EAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AAEA,SACE;AAAQ,IAAA,OAAO,EAAEF,aAAjB;AAAgC,IAAA,KAAK,EAAE;AAAET,MAAAA,KAAK,EAAEF,MAAM,CAACE;AAAhB;AAAvC,KACGF,MAAM,CAACC,IADV,CADF;AAKD,CARiB,CAAlB;AAUA,eAAeR,WAAf","sourcesContent":["import React, {\r\n  useState,\r\n  useEffect,\r\n  useReducer,\r\n  useLayoutEffect,\r\n  useContext,\r\n  useRef,\r\n  memo,\r\n  useMemo,\r\n  useCallback\r\n} from \"react\";\r\n\r\nimport MyContext from \"../../lib/my-context\";\r\n\r\nfunction countReducer(state, action) {\r\n  switch (action.type) {\r\n    case \"add\":\r\n      return state + 1;\r\n    case \"minus\":\r\n      return state - 1;\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction MyCountFunc() {\r\n  const [count, dispatchCount] = useReducer(countReducer, 0);\r\n  const [name, setName] = useState(\"lyn\");\r\n\r\n  const countRef = useRef();\r\n  countRef.current = count;\r\n  // 不加useMemo时候config每次都会重新渲染，都不一样，所以要缓存一下\r\n  const config = useMemo(\r\n    () => ({\r\n      text: `count is ${count}`,\r\n      color: count > 3 ? \"red\" : \"blue\"\r\n    }),\r\n    [count]\r\n  );\r\n  // 如果放在onClick中，每次声明都是声明新的，还是每次都渲染，，方法提出来，然后用useCallback包裹住匿名函数，\r\n  const handleButtonClick = useCallback(\r\n    () => dispatchCount({ type: \"add\" }),\r\n    []\r\n  );\r\n\r\n  const handleAlertButtonClick = () => {\r\n    setTimeout(() => {\r\n      // alert(count)\r\n      alert(countRef.current);\r\n    }, 2000);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <input value={name} onChange={e => setName(e.target.value)} />\r\n      <Child config={config} onButtonClick={handleButtonClick}></Child>\r\n      <button onClick={handleAlertButtonClick}>alert count</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst Child = memo(function Child({ onButtonClick, config }) {\r\n  console.log(\"child render\");\r\n\r\n  return (\r\n    <button onClick={onButtonClick} style={{ color: config.color }}>\r\n      {config.text}\r\n    </button>\r\n  );\r\n});\r\n\r\nexport default MyCountFunc;\r\n"]},"metadata":{},"sourceType":"module"}
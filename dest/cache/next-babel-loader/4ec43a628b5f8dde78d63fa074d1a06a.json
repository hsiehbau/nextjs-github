{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useState, useEffect, useReducer, useLayoutEffect, useContext, useRef, memo, useMemo, useCallback } from \"react\";\nimport MyContext from \"../../lib/my-context\";\n\nfunction countReducer(state, action) {\n  switch (action.type) {\n    case \"add\":\n      return state + 1;\n\n    case \"minus\":\n      return state - 1;\n\n    default:\n      return state;\n  }\n}\n\nfunction MyCountFunc() {\n  const {\n    0: count,\n    1: dispatchCount\n  } = useReducer(countReducer, 0);\n  const {\n    0: name,\n    1: setName\n  } = useState(\"lyn\");\n  const countRef = useRef();\n  countRef.current = count; // 不加useMemo时候config每次都会重新渲染，都不一样，所以要缓存一下\n\n  const config = useMemo(() => ({\n    text: `count is ${count}`,\n    color: count > 3 ? \"red\" : \"blue\"\n  }), [count]); // 如果放在onClick中，每次声明都是声明新的，还是每次都渲染，，方法提出来，然后用useCallback包裹住匿名函数，\n\n  const handleButtonClick = useCallback(() => dispatchCount({\n    type: \"add\"\n  }), []);\n\n  const handleAlertButtonClick = () => {\n    setTimeout(() => {\n      // alert(count)\n      alert(countRef.current);\n    }, 2000);\n  };\n\n  return __jsx(\"div\", null, __jsx(\"input\", {\n    value: name,\n    onChange: e => setName(e.target.value)\n  }), __jsx(Child, {\n    config: config,\n    onButtonClick: handleButtonClick\n  }), __jsx(\"button\", {\n    onClick: handleAlertButtonClick\n  }, \"alert count\"));\n}\n\nconst Child = memo(function Child({\n  onButtonClick,\n  config\n}) {\n  console.log(\"child render\");\n  return __jsx(\"button\", {\n    onClick: onButtonClick,\n    style: {\n      color: config.color\n    }\n  }, config.text);\n});\nexport default MyCountFunc;","map":{"version":3,"sources":["D:/GitHub/nextjs-project/pages/test/b.js"],"names":["React","useState","useEffect","useReducer","useLayoutEffect","useContext","useRef","memo","useMemo","useCallback","MyContext","countReducer","state","action","type","MyCountFunc","count","dispatchCount","name","setName","countRef","current","config","text","color","handleButtonClick","handleAlertButtonClick","setTimeout","alert","e","target","value","Child","onButtonClick","console","log"],"mappings":";AAAA,OAAOA,KAAP,IACEC,QADF,EAEEC,SAFF,EAGEC,UAHF,EAIEC,eAJF,EAKEC,UALF,EAMEC,MANF,EAOEC,IAPF,EAQEC,OARF,EASEC,WATF,QAUO,OAVP;AAYA,OAAOC,SAAP,MAAsB,sBAAtB;;AAEA,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,MAA7B,EAAqC;AACnC,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,KAAL;AACE,aAAOF,KAAK,GAAG,CAAf;;AACF,SAAK,OAAL;AACE,aAAOA,KAAK,GAAG,CAAf;;AACF;AACE,aAAOA,KAAP;AANJ;AAQD;;AAED,SAASG,WAAT,GAAuB;AACrB,QAAM;AAAA,OAACC,KAAD;AAAA,OAAQC;AAAR,MAAyBd,UAAU,CAACQ,YAAD,EAAe,CAAf,CAAzC;AACA,QAAM;AAAA,OAACO,IAAD;AAAA,OAAOC;AAAP,MAAkBlB,QAAQ,CAAC,KAAD,CAAhC;AAEA,QAAMmB,QAAQ,GAAGd,MAAM,EAAvB;AACAc,EAAAA,QAAQ,CAACC,OAAT,GAAmBL,KAAnB,CALqB,CAMrB;;AACA,QAAMM,MAAM,GAAGd,OAAO,CACpB,OAAO;AACLe,IAAAA,IAAI,EAAG,YAAWP,KAAM,EADnB;AAELQ,IAAAA,KAAK,EAAER,KAAK,GAAG,CAAR,GAAY,KAAZ,GAAoB;AAFtB,GAAP,CADoB,EAKpB,CAACA,KAAD,CALoB,CAAtB,CAPqB,CAcrB;;AACA,QAAMS,iBAAiB,GAAGhB,WAAW,CACnC,MAAMQ,aAAa,CAAC;AAAEH,IAAAA,IAAI,EAAE;AAAR,GAAD,CADgB,EAEnC,EAFmC,CAArC;;AAKA,QAAMY,sBAAsB,GAAG,MAAM;AACnCC,IAAAA,UAAU,CAAC,MAAM;AACf;AACAC,MAAAA,KAAK,CAACR,QAAQ,CAACC,OAAV,CAAL;AACD,KAHS,EAGP,IAHO,CAAV;AAID,GALD;;AAOA,SACE,mBACE;AAAO,IAAA,KAAK,EAAEH,IAAd;AAAoB,IAAA,QAAQ,EAAEW,CAAC,IAAIV,OAAO,CAACU,CAAC,CAACC,MAAF,CAASC,KAAV;AAA1C,IADF,EAEE,MAAC,KAAD;AAAO,IAAA,MAAM,EAAET,MAAf;AAAuB,IAAA,aAAa,EAAEG;AAAtC,IAFF,EAGE;AAAQ,IAAA,OAAO,EAAEC;AAAjB,mBAHF,CADF;AAOD;;AAED,MAAMM,KAAK,GAAGzB,IAAI,CAAC,SAASyB,KAAT,CAAe;AAAEC,EAAAA,aAAF;AAAiBX,EAAAA;AAAjB,CAAf,EAA0C;AAC3DY,EAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AAEA,SACE;AAAQ,IAAA,OAAO,EAAEF,aAAjB;AAAgC,IAAA,KAAK,EAAE;AAAET,MAAAA,KAAK,EAAEF,MAAM,CAACE;AAAhB;AAAvC,KACGF,MAAM,CAACC,IADV,CADF;AAKD,CARiB,CAAlB;AAUA,eAAeR,WAAf","sourcesContent":["import React, {\r\n  useState,\r\n  useEffect,\r\n  useReducer,\r\n  useLayoutEffect,\r\n  useContext,\r\n  useRef,\r\n  memo,\r\n  useMemo,\r\n  useCallback\r\n} from \"react\";\r\n\r\nimport MyContext from \"../../lib/my-context\";\r\n\r\nfunction countReducer(state, action) {\r\n  switch (action.type) {\r\n    case \"add\":\r\n      return state + 1;\r\n    case \"minus\":\r\n      return state - 1;\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction MyCountFunc() {\r\n  const [count, dispatchCount] = useReducer(countReducer, 0);\r\n  const [name, setName] = useState(\"lyn\");\r\n\r\n  const countRef = useRef();\r\n  countRef.current = count;\r\n  // 不加useMemo时候config每次都会重新渲染，都不一样，所以要缓存一下\r\n  const config = useMemo(\r\n    () => ({\r\n      text: `count is ${count}`,\r\n      color: count > 3 ? \"red\" : \"blue\"\r\n    }),\r\n    [count]\r\n  );\r\n  // 如果放在onClick中，每次声明都是声明新的，还是每次都渲染，，方法提出来，然后用useCallback包裹住匿名函数，\r\n  const handleButtonClick = useCallback(\r\n    () => dispatchCount({ type: \"add\" }),\r\n    []\r\n  );\r\n\r\n  const handleAlertButtonClick = () => {\r\n    setTimeout(() => {\r\n      // alert(count)\r\n      alert(countRef.current);\r\n    }, 2000);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <input value={name} onChange={e => setName(e.target.value)} />\r\n      <Child config={config} onButtonClick={handleButtonClick}></Child>\r\n      <button onClick={handleAlertButtonClick}>alert count</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nconst Child = memo(function Child({ onButtonClick, config }) {\r\n  console.log(\"child render\");\r\n\r\n  return (\r\n    <button onClick={onButtonClick} style={{ color: config.color }}>\r\n      {config.text}\r\n    </button>\r\n  );\r\n});\r\n\r\nexport default MyCountFunc;\r\n"]},"metadata":{},"sourceType":"module"}